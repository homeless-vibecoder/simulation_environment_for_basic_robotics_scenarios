{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nfrom typing import Dict, Any, Iterable",
    "init": "self.sim = sim\n    self.base_speed = 0.45\n    self.turn_gain = 1.4\n    self.dampen = 0.9",
    "step": " line_vals = sensors.get(\"line_array\") or [0.0, 0.0, 0.0, 0.0, 0.0]\n    if isinstance(line_vals, (int, float)):\n        line_vals = [float(line_vals)]\n    front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    error = self._weighted_error(line_vals)\n    if front < 0.3:\n        self.base_speed = 0.25\n    else:\n        self.base_speed =  0.45\n\n    turn = self.turn_gain * error\n    left_cmd = self.base_speed - turn\n    right_cmd = self.base_speed + turn\n    self._apply(left_cmd, right_cmd, dt)\n    right_motor.command(0)",
    "helpers": "def _weighted_error(self, readings: Iterable[float]) -> float:\n        vals = list(readings)\n        if not vals:\n            return 0.0\n        mid = (len(vals) - 1) / 2.0\n        weighted_sum = 0.0\n        total = 0.0\n        for idx, val in enumerate(vals):\n            weight = idx - mid\n            weighted_sum += weight * (val - 0.5)\n            total += abs(weight)\n        if total == 0.0:\n            return 0.0\n        return _clamp(weighted_sum / total, -1.0, 1.0) * self.dampen\n\ndef _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = _clamp(left, -1.0, 1.0)\n        right = _clamp(right, -1.0, 1.0)\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"base_speed\": self.base_speed}\n\ndef set_state(self, state):\n        self.base_speed = float(state.get(\"base_speed\", self.base_speed))"
  },
  "help": "Step signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, line_array\n\nNotes:\nimports: modules and constants\n__init__: set up state; self.sim and self.robot_id available\nstep: runs every timestep; signature step(sensors, dt)\nhelpers: optional class methods or utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}