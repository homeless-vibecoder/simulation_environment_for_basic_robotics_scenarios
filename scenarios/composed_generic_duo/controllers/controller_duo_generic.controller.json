{
  "name": "controller_duo_generic",
  "sections": {
    "imports": "from __future__ import annotations\nfrom typing import Any, Dict, Iterable\n",
    "init": "self.sim = sim\n    self.robot_id = getattr(self, \"robot_id\", None)\n    # Small bias per robot to keep them from overlapping.\n    self.bias = 0.06 if (self.robot_id or \"\").endswith(\"o\") else -0.06\n    self.base_speed = 0.38\n    self.turn_gain = 1.2\n",
    "step": "line_vals = sensors.get(self._name(\"line_array\")) or sensors.get(\"line_array\")\n    error = self._weighted_error(line_vals) if line_vals is not None else 0.0\n    turn = self.turn_gain * error + self.bias\n    left_cmd = self.base_speed - turn\n    right_cmd = self.base_speed + turn\n    self._apply(left_cmd, right_cmd, dt)\n",
    "helpers": "def _weighted_error(self, readings: Iterable[float]) -> float:\n        vals = list(readings) if isinstance(readings, (list, tuple)) else [float(readings)]\n        if not vals:\n            return 0.0\n        mid = (len(vals) - 1) / 2.0\n        weighted_sum = 0.0\n        total = 0.0\n        for idx, val in enumerate(vals):\n            weight = idx - mid\n            weighted_sum += weight * (float(val) - 0.5)\n            total += abs(weight)\n        if total == 0.0:\n            return 0.0\n        return _clamp(weighted_sum / total, -1.0, 1.0)\n\ndef _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(self._name(\"left_motor\")) or self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(self._name(\"right_motor\")) or self.sim.motors.get(\"right_motor\")\n        left = _clamp(left, -0.9, 0.9)\n        right = _clamp(right, -0.9, 0.9)\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef _name(self, base: str) -> str:\n        return f\"{self.robot_id}/{base}\" if self.robot_id else base\n"
  },
  "help": "imports: modules and constants\n__init__: set up state; self.sim and self.robot_id available\nstep: runs every timestep; signature step(sensors, dt)\nhelpers: optional class methods or utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}