{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nfrom typing import Dict, Any\n",
    "init": "self.sim = sim\n    self.base_speed = 0.4\n    self.balance_gain = 1.2\n    self.avoid_gain = 0.9\n",
    "step": "front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    left = float(sensors.get(\"left_distance\", 0.4) or 0.4)\n    right = float(sensors.get(\"right_distance\", 0.4) or 0.4)\n\n    left_cmd = self.base_speed\n    right_cmd = self.base_speed\n\n    if front < 0.25:\n        left_cmd = -0.1\n        right_cmd = self.base_speed + self.avoid_gain\n    else:\n        error = left - right\n        correction = self.balance_gain * error\n        left_cmd = self.base_speed + correction\n        right_cmd = self.base_speed - correction\n\n    self._apply(left_cmd, right_cmd, dt)\n",
    "helpers": "def _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = max(-1.0, min(1.0, left))\n        right = max(-1.0, min(1.0, right))\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"base_speed\": self.base_speed}\n\ndef set_state(self, state):\n        self.base_speed = float(state.get(\"base_speed\", self.base_speed))\n"
  },
  "help": "imports: optional modules/constants\n__init__: set up state; self.sim and self.robot_id available\nstep(sensors, dt): runs every timestep; return None\nhelpers: optional class methods/utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}