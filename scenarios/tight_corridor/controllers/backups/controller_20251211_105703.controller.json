{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nfrom typing import Dict, Any",
    "init": "self.sim = sim\n    self.base_speed = 0.4\n    self.balance_gain = 1.2\n    self.avoid_gain = 0.9",
    "step": "front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    left = float(sensors.get(\"left_distance\", 0.4) or 0.4)\n    right = float(sensors.get(\"right_distance\", 0.4) or 0.4)\n\n    left_cmd = self.base_speed\n    right_cmd = self.base_speed\n\n    if front < 0.25:\n        left_cmd = -0.1\n        right_cmd = self.base_speed + self.avoid_gain\n    else:\n        error = left - right\n        correction = self.balance_gain * error\n        left_cmd = self.base_speed + correction\n        right_cmd = self.base_speed - correction\n\n    self._apply(left_cmd  , right_cmd, dt)",
    "helpers": "def _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = max(-1.0, min(1.0, left))\n        right = max(-1.0, min(1.0, right))\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"base_speed\": self.base_speed}\n\ndef set_state(self, state):\n        self.base_speed = float(state.get(\"base_speed\", self.base_speed))"
  },
  "help": "Step signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, left_distance, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, left_distance, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, left_distance, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, left_distance, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, left_distance, right_distance\n\nNotes:\nimports: optional modules/constants\n__init__: set up state; self.sim and self.robot_id available\nstep(sensors, dt): runs every timestep; return None\nhelpers: optional class methods/utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}