{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nimport math\nfrom typing import Dict, Any",
    "init": "self.sim = sim\n    self.phase = 0.0\n    self.base_speed = 0.65\n    self.turn_amplitude = 0.35",
    "step": "front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    right = float(sensors.get(\"right_distance\", 1.5) or 1.5)\n\n    # Advance the oscillation for the slalom weave.\n    self.phase += dt * 1.2\n    turn = math.sin(self.phase)\n\n    speed = self.base_speed\n    if front < 0.45 or right < 0.25:\n        speed = 0.35\n        turn += 0.4  # nudge left when boxed in\n\n    left_cmd = speed - self.turn_amplitude * turn\n    right_cmd = speed + self.turn_amplitude * turn\n    self._apply(left_cmd, right_cmd, dt)",
    "helpers": "def _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = max(-1.0, min(1.0, left))\n        right = max(-1.0, min(1.0, right))\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"phase\": self.phase}\n\ndef set_state(self, state):\n        self.phase = float(state.get(\"phase\", self.phase))"
  },
  "help": "Step signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, right_distance\n\nNotes:\nStep signature: step(sensors, dt) \u2014 runs every sim tick.\nSensors: dict keyed by sensor names; values depend on sensor type.\nMotors: access via self.sim.motors['name'].command(value, self.sim, dt).\nContext: self.sim (physics + devices), self.robot_id (id for multi-robot).\nCommon patterns: clamp outputs, read sensors safely, respect dt for rates.\nAvailable motors: left_motor, right_motor\nAvailable sensors: front_distance, imu, right_distance\n\nNotes:\nimports: optional modules/constants\n__init__: set up state; self.sim and self.robot_id available\nstep(sensors, dt): runs every timestep; return None\nhelpers: optional class methods/utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}