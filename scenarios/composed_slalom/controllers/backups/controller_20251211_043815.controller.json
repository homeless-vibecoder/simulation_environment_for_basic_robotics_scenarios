{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nimport math\nfrom typing import Dict, Any\n",
    "init": "self.sim = sim\n    self.phase = 0.0\n    self.base_speed = 0.65\n    self.turn_amplitude = 0.35\n",
    "step": "front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    right = float(sensors.get(\"right_distance\", 1.5) or 1.5)\n\n    # Advance the oscillation for the slalom weave.\n    self.phase += dt * 1.2\n    turn = math.sin(self.phase)\n\n    speed = self.base_speed\n    if front < 0.45 or right < 0.25:\n        speed = 0.35\n        turn += 0.4  # nudge left when boxed in\n\n    left_cmd = speed - self.turn_amplitude * turn\n    right_cmd = speed + self.turn_amplitude * turn\n    self._apply(left_cmd, right_cmd, dt)\n",
    "helpers": "def _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = max(-1.0, min(1.0, left))\n        right = max(-1.0, min(1.0, right))\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"phase\": self.phase}\n\ndef set_state(self, state):\n        self.phase = float(state.get(\"phase\", self.phase))\n"
  },
  "help": "imports: optional modules/constants\n__init__: set up state; self.sim and self.robot_id available\nstep(sensors, dt): runs every timestep; return None\nhelpers: optional class methods/utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}