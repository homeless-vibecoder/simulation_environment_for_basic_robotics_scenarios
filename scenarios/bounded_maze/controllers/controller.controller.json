{
  "name": "controller",
  "sections": {
    "imports": "from __future__ import annotations\nfrom typing import Dict, Any\n",
    "init": "self.sim = sim\n    self.base_speed = 0.55\n    self.turn_gain = 0.9\n    self.avoid_gain = 0.8\n",
    "step": "front = float(sensors.get(\"front_distance\", 1.5) or 1.5)\n    left = float(sensors.get(\"left_distance\", 1.0) or 1.0)\n    right = float(sensors.get(\"right_distance\", 1.0) or 1.0)\n\n    left_cmd = self.base_speed\n    right_cmd = self.base_speed\n\n    # Avoid front collisions first.\n    if front < 0.35:\n        left_cmd = -0.15\n        right_cmd = self.base_speed + self.avoid_gain\n    else:\n        # Bias toward left-hand wall following.\n        error = left - right\n        correction = self.turn_gain * error\n        left_cmd = self.base_speed + correction\n        right_cmd = self.base_speed - correction\n\n    self._apply(left_cmd, right_cmd, dt)\n",
    "helpers": "def _apply(self, left: float, right: float, dt: float) -> None:\n        left_motor = self.sim.motors.get(\"left_motor\")\n        right_motor = self.sim.motors.get(\"right_motor\")\n        left = max(-1.0, min(1.0, left))\n        right = max(-1.0, min(1.0, right))\n        if left_motor:\n            left_motor.command(left, self.sim, dt)\n        if right_motor:\n            right_motor.command(right, self.sim, dt)\n\ndef get_state(self):\n        return {\"base_speed\": self.base_speed}\n\ndef set_state(self, state):\n        self.base_speed = float(state.get(\"base_speed\", self.base_speed))\n"
  },
  "help": "imports: modules and constants\n__init__: set up state; self.sim and self.robot_id available\nstep: runs every timestep; signature step(sensors, dt)\nhelpers: optional class methods or utilities\n\n(migrated from legacy controller.py)",
  "meta": {},
  "version": 1
}